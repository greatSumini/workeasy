{
  "rules": [
    {
      "type": "prd",
      "content": "# workeasy – Product Requirement Document\n\n## 1. One-line Summary\n모바일-퍼스트 PWA로 소규모 F&B 매장의 교대근무 자동화와 실시간 근무 교환, 채팅·푸시 알림을 한 번에 제공하는 SaaS.\n\n## 2. Problem Statement\n소규모 카페·레스토랑은 여전히 엑셀과 카카오톡으로 근무 교환을 관리해 승인 지연, 근무 공백, 일정 오류가 빈번하다. 매니저는 시간과 노력을 크게 낭비하고, 알바생은 즉각적인 확인이 어렵다.\n\n## 3. Goals & Success Metrics\n| 목표 | 지표 | 목표값 |\n|------|------|-------|\n| 근무 교환 처리 시간 단축 | 요청→승인까지 평균 소요 시간 | 2분 이하 |\n| 매니저 스케줄 편성 시간 절감 | 주간 스케줄 작성/수정 시간 | 70% 절감 |\n| 근무 공백 제거 | 스케줄 오류로 인한 No-show | 월 0건 |\n| 사용자 활성도 | PWA DAU/MAU | 60% 이상 |\n\n## 4. Target Users (Personas)\n1. **매장 관리자 ‘민지’(32세)** – 8명의 알바를 관리, 근무표 수정·승인에 매주 3시간 이상 소비.\n2. **알바생 ‘지수’(22세)** – 수업 일정이 자주 바뀌어 근무 교환을 빠르게 처리해야 함.\n\n타깃 매장 규모: 알바생 1 – 10명, 교대 빈도가 높은 소형 카페·식당.\n\n## 5. Main Use Case (MVP)\n지수가 금요일 근무를 바꿔야 해서 앱 → 근무 카드 → ‘교환 요청’ → 동료 선택 → 민지가 푸시 알림 → 1탭 승인 → 전 직원 일정 실시간 업데이트.\n\n## 6. Feature List & Priority\n| 우선순위 | 기능 | 설명 |\n|----------|------|------|\n| P0 | 교대근무 자동 스케줄러 | 알바 가능 시간·근로 규정 기반 자동 배정 |\n| P0 | 근무 교환 요청/승인 | 요청 생성, 매니저 1탭 승인, 일정 즉시 반영 |\n| P0 | 실시간 채팅 & 공지 | 매장 단위 채팅방, 공지 고정, 파일 첨부(10MB) |\n| P0 | PWA 설치 & 푸시알림 | iOS/Android 홈화면 설치, Web Push |\n| P1 | 기본 통계 & 관리자 대시보드 | 근무 시간·인건비 요약, 교환 로그, 빈 슬롯 경고 |\n| P2 | CSV 내보내기·통합 | 추후 POS/급여 시스템 연동 |\n\n## 7. Functional Requirements (MVP)\nFR-1 개인·매장 캘린더(일/주/월) 뷰 제공\nFR-2 알바생이 교환 요청 시 대체 인원 선택 또는 마켓플레이스 공개\nFR-3 매니저는 알림 클릭 한 번으로 승인/거절 가능\nFR-4 승인 시 모든 사용자의 일정이 실시간으로 갱신되고 로그에 기록\nFR-5 모든 요청·승인·거절 이벤트에 푸시알림 발송 (<1초 지연)\nFR-6 채팅방에서 @멘션, 사진·PDF 첨부 가능\nFR-7 오프라인 상태에서도 캘린더 조회 가능, 온라인 시 자동 동기화\n\n## 8. Non-Functional Requirements\n• 모바일 Lighthouse PWA 점수 90 이상\n• 채팅·일정 변경 실시간 지연 ≤ 1초\n• GDPR/KISA 준수, 데이터 암호화 at-rest\n• 초기 파일럿: 동시 접속 500명, 매장 2,000곳까지 안정 동작\n\n## 9. Tech Stack (EasyNext 기본)\nFrontend: Next.js 15, TypeScript, shadcn/ui, lucide-react, tailwindcss, @tanstack/react-query, date-fns\nBackend: Supabase (PostgreSQL, Realtime, Auth)\nInfra: Vercel + Supabase, es-toolkit 배포 자동화\n\n## 10. Release Plan\n1개월: 디자인 & 스케줄 알고리즘 PoC\n2개월: P0 기능 개발·내부 QA\n3개월: 3개 카페 MVP 베타 론칭\n4개월: 피드백 반영·대시보드(P1) 추가\n5개월: 공개 베타 & 과금 모델 적용\n\n## 11. Out of Scope (MVP)\n• 급여 신고용 4대 보험 서식\n• 멀티 언어 지원\n• AI 수요 예측\n\n## 12. Risks & Mitigation\nR1 복잡한 근무 규정 → 초기엔 단순 규칙, 규정 예외 수동 수정 허용\nR2 iOS 웹푸시 제한 → APNs Web Push 적용, 한시적 SMS 백업 고려\nR3 온보딩 장벽 → 설치 가이드 튜토리얼, 카카오톡 로그인 지원\n",
      "writedAt": "2025-08-14T11:43:18.413Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n\n### Project Overview\n본 프로젝트는 소규모 F&B 매장을 위한 교대근무 관리 서비스 'workeasy'를 모바일-퍼스트 프로그레시브 웹 앱(PWA)으로 개발하는 것을 목표로 합니다. Next.js와 Supabase를 중심으로 한 서버리스 아키텍처를 채택하여, 실시간 근무 교환, 채팅, 푸시 알림 기능을 신속하게 구현합니다. 핵심은 복잡한 백엔드 인프라 구축 없이 Supabase의 BaaS(Backend as a Service) 기능을 최대한 활용하여 개발 속도와 운영 효율성을 극대화하는 것입니다.\n\n### Core Technology Stack\n-   **Frontend**: Next.js 15, TypeScript, shadcn/ui, Tailwind CSS\n-   **Backend & Database**: Supabase (PostgreSQL, Realtime, Auth, Storage)\n-   **State Management & Data Fetching**: @tanstack/react-query\n-   **Infrastructure**: Vercel, Supabase\n\n### Key Technical Objectives\n-   **실시간 동기화**: 근무 일정 변경 및 채팅 메시지의 실시간 전파 지연 시간을 1초 이내로 유지합니다.\n-   **모바일 최적화**: Lighthouse PWA 점수 90점 이상을 달성하여 네이티브 앱 수준의 사용자 경험을 제공합니다.\n-   **초기 확장성**: 파일럿 단계에서 동시 접속 500명,",
      "writedAt": "2025-08-14T11:43:18.413Z"
    },
    {
      "type": "guideline",
      "content": "\n  # Senior Developer Guidelines\n  \n  ## Must\n  \n  - always use client component for all components. (use `use client` directive)\n  - always use promise for page.tsx params props.\n  - use valid picsum.photos stock image for placeholder image\n  \n  ## Library\n  \n  use following libraries for specific functionalities:\n  \n  1. `date-fns`: For efficient date and time handling.\n  2. `ts-pattern`: For clean and type-safe branching logic.\n  3. `@tanstack/react-query`: For server state management.\n  4. `zustand`: For lightweight global state management.\n  5. `react-use`: For commonly needed React hooks.\n  6. `es-toolkit`: For robust utility functions.\n  7. `lucide-react`: For customizable icons.\n  8. `zod`: For schema validation and data integrity.\n  9. `shadcn-ui`: For pre-built accessible UI components.\n  10. `tailwindcss`: For utility-first CSS styling.\n  11. `supabase`: For a backend-as-a-service solution.\n  12. `react-hook-form`: For form validation and state management.\n  \n  ## Directory Structure\n  \n  - src\n  - src/app: Next.js App Routers\n  - src/components/ui: shadcn-ui components\n  - src/constants: Common constants\n  - src/hooks: Common hooks\n  - src/lib: utility functions\n  - src/remote: http client\n  - src/features/[featureName]/components/*: Components for specific feature\n  - src/features/[featureName]/constants/*\n  - src/features/[featureName]/hooks/*\n  - src/features/[featureName]/lib/*\n  - src/features/[featureName]/api.ts: api fetch functions\n  \n  ## Solution Process:\n  \n  1. Rephrase Input: Transform to clear, professional prompt.\n  2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n  3. Develop Solution:\n     - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n     - List steps numerically.\n     - \"To resolve these steps, I need the following solutions:\"\n     - List solutions with bullet points.\n  4. Validate Solution: Review, refine, test against edge cases.\n  5. Evaluate Progress:\n     - If incomplete: Pause, inform user, await input.\n     - If satisfactory: Proceed to final output.\n  6. Prepare Final Output:\n     - ASCII title\n     - Problem summary and approach\n     - Step-by-step solution with relevant code snippets\n     - Format code changes:\n      ```language:path/to/file\n       // ... existing code ...\n       function exampleFunction() {\n           // Modified or new code here\n       }\n       // ... existing code ...\n       ```\n     - Use appropriate formatting\n     - Describe modifications\n     - Conclude with potential improvements\n  \n  ## Key Mindsets:\n  \n  1. Simplicity\n  2. Readability\n  3. Maintainability\n  4. Testability\n  5. Reusability\n  6. Functional Paradigm\n  7. Pragmatism\n  \n  ## Code Guidelines:\n  \n  1. Early Returns\n  2. Conditional Classes over ternary\n  3. Descriptive Names\n  4. Constants > Functions\n  5. DRY\n  6. Functional & Immutable\n  7. Minimal Changes\n  8. Pure Functions\n  9. Composition over inheritance\n  \n  ## Functional Programming:\n  \n  - Avoid Mutation\n  - Use Map, Filter, Reduce\n  - Currying and Partial Application\n  - Immutability\n  \n  ## Code-Style Guidelines\n  \n  - Use TypeScript for type safety.\n  - Follow the coding standards defined in the ESLint configuration.\n  - Ensure all components are responsive and accessible.\n  - Use Tailwind CSS for styling, adhering to the defined color palette.\n  - When generating code, prioritize TypeScript and React best practices.\n  - Ensure that any new components are reusable and follow the existing design patterns.\n  - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n  - Always validate user inputs and handle errors gracefully.\n  - Use the existing components and pages as a reference for the new components and pages.\n  \n  ## Performance:\n  \n  - Avoid Premature Optimization\n  - Profile Before Optimizing\n  - Optimize Judiciously\n  - Document Optimizations\n  \n  ## Comments & Documentation:\n  \n  - Comment function purpose\n  - Use JSDoc for JS\n  - Document \"why\" not \"what\"\n  \n  ## Function Ordering:\n  \n  - Higher-order functionality first\n  - Group related functions\n  \n  ## Handling Bugs:\n  \n  - Use TODO: and FIXME: comments\n  \n  ## Error Handling:\n  \n  - Use appropriate techniques\n  - Prefer returning errors over exceptions\n  \n  ## Testing:\n  \n  - Unit tests for core functionality\n  - Consider integration and end-to-end tests\n  \n  ## Next.js\n  \n  - you must use promise for page.tsx params props.\n  \n  ## Shadcn-ui\n  \n  - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n  - example\n    ```\n    $ npx shadcn@latest add card\n    $ npx shadcn@latest add textarea\n    $ npx shadcn@latest add dialog\n    ```\n  \n  ## Supabase\n  \n  - if you need to add new table, please create migration. I'll paste it into supabase.\n  - do not run supabase locally\n  - store migration query for `.sql` file. in /supabase/migrations/\n  \n  ## Package Manager\n  \n  - use npm as package manager.\n  \n  ## Korean Text\n  \n  - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n  \n  You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n  Apply these principles judiciously, considering project and team needs.\n    ",
      "writedAt": "2025-08-14T11:43:18.413Z"
    },
    {
      "type": "design-guide",
      "content": "# workeasy 디자인 가이드\n\n## 1. 전체적인 무드 (전체적인 무드)\nworkeasy는 소규모 F&B 매장의 비효율적인 근무 관리를 해결하는 전문적인 SaaS입니다. 따라서 디자인은 신뢰성, 효율성, 명확성에 초점을 맞춥니다. 사용자가 최소한의 노력으로 빠르고 정확하게 업무를 처리할 수 있도록 돕는 직관적이고 군더더기 없는 '도구'로서의 정체성을 강조합니다. 불필요한 장식 요소를 배제하고, 기능에 집중한 미니멀리즘을 통해 매니저와 아르바이트생 모두에게 높은 사용성을 제공하는 것을 목표로 합니다.\n\n## 2. 참조 서비스 (참조 서비스)\n- **Name**: Notion\n- **Description**: 노트, 문서, 프로젝트 관리, 위키 등을 하나로 통합한 올인원 생산성 앱입니다.\n- **Design Mood**: 텍스트와 구조 중심의 미니멀리즘. 충분한 여백을 활용하여 복잡한 정보를 명확하게 전달하며, 사용자가 콘텐츠에 집중할 수 있도록 기능적인 디자인을 채택했습니다.\n- **Primary Color**: `#191919` (거의 검은색에 가까운 텍스트)\n- **Secondary Color**: `#FFFFFF` (기본 배경)\n\n## 3. 색상 & 그라데이션 (색상 & 그라데이션)\n안정감과 신뢰를 주는 파란색을 주 색상으로 사용하며",
      "writedAt": "2025-08-14T11:43:18.413Z"
    },
    {
      "type": "ia",
      "content": "# workeasy 정보 아키텍처(IA)\n\n## 1. 사이트맵 (Site Map)\n\nworkeasy 서비스는 인증 여부와 사용자 역할(관리자, 직원)에 따라 접근 가능한 페이지가 구분됩니다. 전체 구조는 다음과 같습니다.\n\n- **Public (인증 전)**\n  - `/landing` - 서비스 소개 및 로그인/회원가입 유도 페이지\n  - `/login` - 이메일 또는 카카오톡 로그인\n  - `/signup` - 회원가입\n  - `/password-reset` - 비밀번호 재설정\n\n- **Authenticated (인증 후 - 공통)**\n  - `/` 또는 `/dashboard` - **대시보드 (홈)**\n    - 오늘의 근무 현황, 최근 공지, 수신된 요청 요약\n  - `/schedule` - **근무 캘린더**\n    - 개인 및 전체 팀 근무 일정 (일/주/월별 보기)\n  - `/requests` - **교환 요청**\n    - 내가 보낸 요청 목록\n    - 내가 받은 요청 목록\n    - `/requests/:id` - 요청 상세 보기\n  - `/chat` - **채팅**\n    - `/chat/:channelId` - 매장별 채팅방\n  - `/notifications` - **알림**\n    - 모든 활동에 대한 알림 피드\n  - `/settings` - **설정**\n    - `/settings/profile` - 내 프로필 수정\n    - `/settings/notifications` - 알림 설정\n    - `/settings/app` - PWA 설치 가이드, 앱 정보\n\n- **Authenticated (인증 후 - 관리자 전용)**\n  - `/admin/dashboard` - **관리자 대시보드**\n    - 전체 근무 시간, 예상 인건비, 공석 경고 등 통계\n  - `/admin/staff` - **직원 관리**\n    - 직원 목록, 초대, 역할 변경\n  - `/admin/settings` - **매장 설정**\n    - 매장 정보, 근무 규정 설정\n\n## 2. 사용자 흐름 (User Flow)\n\n**주요 과업 1: 알바생 '지수'의 근무 교환 요청 및 처리**\n\n1.  **시작**: 알바생 '지수'가 PWA를 실행합니다.\n2.  **내비게이션**: 하단 탭 바 또는 사이드바에서 '근무 캘린더'로 이동합니다.\n3.  **상호작용**: 교환을 원하는 날짜의 '근무 카드'를 탭합니다.\n4.  **액션**: 상세 정보 팝업에서 '교환 요청' 버튼을 클릭합니다.\n5.  **폼 작성**:\n    - 교환을 희망하는 동료('현우')를 목록에서 선택합니다.\n    - 간단한 요청 사유를 입력합니다.\n    - '요청 보내기' 버튼을 클릭합니다.\n6.  **시스템**:\n    - 관리자 '민지'와 동료 '현우'에게 푸시 알림이 전송됩니다.\n    - 요청 상태가 '대기 중'으로 변경되어 '교환 요청' 페이지에 표시됩니다.\n7.  **관리자 승인**: 관리자 '민지'가 푸시 알림을 탭하여 앱 내 요청 상세 페이지로 바로 이동합니다.\n8.  **결정**: '승인' 버튼을 1탭하여 요청을 승인합니다.\n9.  **완료**:\n    - 시스템이 '지수'와 '현우'의 캘린더를 실시간으로 업데이트합니다.\n    - 관련된 모든 사용자(지수, 현우, 민지)에게 '승인 완료' 푸시 알림이 전송됩니다.\n    - 교환 내역이 로그에 기록됩니다.\n\n**주요 과업 2: 관리자 '민지'의 주간 스케줄 자동 생성 및 배포**\n\n1.  **시작**: 관리자 '민지'가 PWA를 실행하고 '근무 캘린더'로 이동합니다.\n2.  **뷰 변경**: 캘린더 보기 옵션을 '주(Week)' 단위로 변경합니다.\n3.  **자동 생성**:\n    - '스케줄 자동 생성' 버튼을 클릭합니다.\n    - 시스템이 사전에 입력된 직원별 근무 가능 시간과 매장 규정을 기반으로 최적의 스케줄 초안을 생성하여 화면에 표시합니다.\n4.  **수동 조정**:\n    - 특정 근무 슬롯을 드래그 앤 드롭하여 다른 직원에게 할당하거나 시간을 미세 조정합니다.\n    - 비어있는 슬롯을 클릭하여 수동으로 근무를 추가합니다.\n5.  **저장 및 배포**:\n    - '저장 및 공지' 버튼을 클릭합니다.\n    - 시스템이 모든 직원에게 '새로운 주간 스케줄이 등록되었습니다'라는 푸시 알림과 함께 채팅방에 공지를 전송합니다.\n6.  **완료**:\n    - 모든 직원의 캘린더에 새로운 스케줄이 즉시 반영됩니다.\n    - 관리자 대시보드의 '주간 예상 인건비' 위젯이 업데이트됩니다.\n\n## 3. 네비게이션 구조 (Navigation Structure)\n\nworkeasy는 모바일-퍼스트 PWA이므로, 모바일과 데스크톱 환경에 최적화된 네비게이션을 제공합니다.\n\n-   **모바일 (Mobile)**\n    -   **탑 바 (Top Bar)**: 현재 페이지의 제목과 우측에 알림 아이콘, 프로필 아이콘을 배치합니다.\n    -   **메인 네비게이션 (Main Navigation - Drawer Menu)**:\n        -   화면 좌측 상단의 햄버거 아이콘(☰)을 통해 접근합니다.\n        -   주요 메뉴(대시보드, 근무 캘린더, 교환 요청, 채팅, 설정)로 빠르게 이동할 수 있는 링크를 제공합니다.\n        -   관리자일 경우, '관리자 메뉴' 섹션이 추가로 노출됩니다.\n\n-   **데스크톱 (Desktop)**\n    -   **좌측 사이드바 (Left Sidebar - GNB)**:\n        -   화면 좌측에 고정된 슬림한 사이드바로, 아이콘 기반의 네비게이션을 제공합니다.\n        -   포함 메뉴: 대시보드, 근무 캘린더, 교환 요청, 채팅, 설정, 관리자 메뉴(관리자 전용).\n        -   마우스 호버 시 메뉴명이 텍스트로 확장되어 표시됩니다.\n    -   **탑 바 (Top Bar)**:\n        -   사용자 프로필 드롭다운(내 정보, 로그아웃), 알림 센터 아이콘, 매장 선택 드롭다운(여러 매장 관리 시)을 포함합니다.\n\n## 4. 페이지 계층 구조 (Page Hierarchy)\n\n페이지의 깊이(Depth)는 들여쓰기로 표현합니다.\n\n-   `/` (Depth 1) - 인증 상태에 따라 `/dashboard` 또는 `/login`으로 리디렉션\n-   `/login` (Depth 1)\n-   `/signup` (Depth 1)\n-   `/password-reset` (Depth 1)\n-   `/dashboard` (Depth 1)\n-   `/schedule` (Depth 1)\n-   `/requests` (Depth 1)\n    -   `/requests/:id` (Depth 2)\n-   `/chat` (Depth 1)\n    -   `/chat/:channelId` (Depth 2)\n-   `/notifications` (Depth 1)\n-   `/settings` (Depth 1)\n    -   `/settings/profile` (Depth 2)\n    -   `/settings/notifications` (Depth 2)\n    -   `/settings/app` (Depth 2)\n-   `/admin` (Depth 1) - 관리자 전용 네임스페이스\n    -   `/admin/dashboard` (Depth 2)\n    -   `/admin/staff` (Depth 2)\n    -   `/admin/settings` (Depth 2)\n\n## 5. 콘텐츠 구성 (Content Organization)\n\n주요 페이지에 포함될 핵심 콘텐츠 요소를 정의합니다.\n\n| 페이지 | 주요 콘텐츠 요소 |\n| :--- | :--- |\n| **대시보드 (`/dashboard`)** | - **요약 위젯**: 오늘의 근무자, 처리 대기 중인 교환 요청, 최근 공지사항<br>- **빠른 액션 버튼**: '근무 추가', '공지 작성'<br>- **캘린더 미니뷰**: 금일 및 익일 스케줄 하이라이트 |\n| **근무 캘린더 (`/schedule`)** | - **캘린더 뷰**: 일/주/월 단위 보기 전환 토글<br>- **필터**: 직원별, 포지션별 필터링 옵션<br>- **근무 카드(Shift Card)**: 시간, 담당자, 상태(확정, 대기) 표시<br>- **액션 버튼**: '스케줄 자동 생성'(관리자), '교환 요청'(직원) |\n| **교환 요청 상세 (`/requests/:id`)** | - **요청 정보**: 요청자, 기존 근무 시간, 요청 사유<br>- **대체 근무 정보**: 제안된 대체 근무자 및 시간<br>- **타임라인**: 요청 생성 → 승인/거절까지의 로그<br>- **액션 버튼**: '승인', '거절' (관리자), '요청 취소'(요청자) |\n| **채팅 (`/chat/:channelId`)** | - **메시지 목록**: 대화 내용, 보낸 사람, 시간, 파일/이미지 썸네일<br>- **고정된 공지**: 채팅방 상단에 고정된 중요 공지<br>- **입력창**: 텍스트 입력, 파일 첨부(이미지, PDF), @멘션 기능 |\n| **관리자 대시보드 (`/admin/dashboard`)** | - **핵심 지표(KPI) 카드**: 주간/월간 총 근무 시간, 예상 인건비, 평균 교환 처리 시간<br>- **차트/그래프**: 요일별 인력 분포, 직원별 근무 시간 통계<br>- **경고 위젯**: 근무 공백(빈 슬롯) 발생 위험 알림 |\n\n## 6. 인터랙션 패턴 (Interaction Patterns)\n\n서비스 전반에 걸쳐 일관된 사용자 경험을 제공하기 위해 다음 인터랙션 패턴을 사용합니다.\n\n-   **모달 (Modal)**: 중요한 결정(예: 근무 교환 승인/거절)이나 여러 단계의 정보 입력(예: 새 근무 생성)이 필요할 때 사용합니다. 배경을 어둡게 처리하여 사용자가 현재 과업에 집중하도록 돕습니다.\n-   **푸시 알림 (Push Notification)**: 근무 교환 요청, 승인/거절, 새 공지, 채팅 멘션 등 즉각적인 확인이 필요한 모든 이벤트에 사용됩니다. 알림 클릭 시 관련 페이지로 직접 이동(Deep Linking)합니다.\n-   **실시간 업데이트 (Real-time Update)**: Supabase Realtime을 활용하여 캘린더, 채팅, 대시보드 위젯 등의 데이터 변경 사항을 별도의 새로고침 없이 1초 이내에 화면에 반영합니다.\n-   **토스트/스낵바 (Toast/Snackbar)**: '저장되었습니다', '요청이 전송되었습니다'와 같이 작업을 차단하지 않는 간단한 피드백을 화면 하단이나 상단에 잠시 표시합니다.\n-   **스켈레톤 로딩 (Skeleton Loading)**: 데이터를 불러오는 동안 실제 콘텐츠의 레이아웃과 유사한 회색 스켈레톤 UI를 표시하여 사용자가 인지하는 로딩 시간을 단축시킵니다.\n-   **1탭 액션 (One-Tap Action)**: 관리자의 빠른 의사결정을 위해 푸시 알림이나 리스트 항목에서 '승인'과 같은 주요 액션을 한 번의 탭으로 완료할 수 있도록 설계합니다.\n\n## 7. URL 구조 (URL Structure)\n\n사용자 친화적이고 검색 엔진 최적화(SEO)에 유리한 명확하고 일관된 URL 구조를 정의합니다.\n\n-   **리소스 기반**: 각 URL은 특정 리소스(예: `schedules`, `requests`)를 나타냅니다.\n-   **계층 구조 반영**: URL 경로는 페이지 계층 구조를 직관적으로 반영합니다.\n-   **케밥 케이스(kebab-case)**: 여러 단어로 이루어진 경로는 하이픈(-)으로 연결합니다. (예: `/password-reset`)\n\n| 구분 | URL 구조 예시 | 설명 |\n| :--- | :--- | :--- |\n| **전체 목록** | `/schedule`, `/requests` | 특정 리소스의 목록 페이지 |\n| **상세 정보** | `/requests/:id` | 특정 리소스의 고유 ID를 사용한 상세 페이지 |\n| **생성/수정** | `/requests/new`, `/requests/:id/edit` | 리소스 생성 및 수정 페이지 (주로 모달로 처리) |\n| **사용자별** | `/settings/profile` | 사용자 개인에 종속된 리소스 페이지 |\n| **관리자** | `/admin/dashboard`, `/admin/staff` | 관리자 전용 기능을 명확히 구분하는 `admin` 접두사 |\n\n## 8. 컴포넌트 계층 구조 (Component Hierarchy)\n\n재사용성을 극대화하고 일관된 디자인을 유지하기 위해 페이지를 컴포넌트 단위로 분해합니다. (shadcn/ui 기반)\n\n-   **글로벌 컴포넌트 (Global Components)**\n    -   `AppLayout`: 전체적인 페이지 레이아웃을 정의 (사이드바, 탑 바, 메인 콘텐츠 영역)\n    -   `SidebarNav`: 데스크톱용 좌측 사이드바 네비게이션\n    -   `MobileDrawer`: 모바일용 드로어 메뉴\n    -   `TopBar`: 사용자 프로필, 알림 벨 등이 포함된 상단 바\n    -   `NotificationCenter`: 알림 목록을 보여주는 드롭다운 또는 패널\n\n-   **기능별 컴포넌트 (Feature-specific Components)**\n    -   `CalendarView`: 일/주/월 보기 로직이 포함된 캘린더 컴포넌트\n    -   `ShiftCard`: 캘린더 내 개별 근무 정보를 표시하는 카드\n    -   `ShiftRequestModal`: 근무 교환 요청을 생성하는 모달\n    -   `DashboardWidget`: 대시보드에 사용되는 각 통계 및 요약 카드\n    -   `ChatWindow`: 메시지 목록과 입력창을 포함한 채팅 인터페이스\n    -   `ChatMessage`: 채팅 메시지 버블 (내 메시지, 상대 메시지)\n\n-   **원자적 컴포넌트 (Atomic Components - from shadcn/ui)**\n    -   `Button`: 다양한 형태의 버튼 (Primary, Secondary, Destructive)\n    -   `Input`: 텍스트 입력 필드\n    -   `Avatar`: 사용자 프로필 이미지\n    -   `Badge`: 상태(예: 대기중, 승인) 표시용 뱃지\n    -   `Dialog`: 모달의 기본 구조\n    -   `Toast`: 스낵바 알림\n    -   `Card`: 콘텐츠를 감싸는 기본 카드 UI\n    -   `Skeleton`: 스켈레톤 로딩 UI",
      "writedAt": "2025-08-14T11:43:18.413Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-14T11:43:18.413Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-14T11:43:18.413Z"
    }
  ]
}